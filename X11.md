<div align="center">

# ğŸ§  Comprendre X11

### *Guide pÃ©dagogique appliquÃ© au projet Black Hole Locker*

![X11](https://img.shields.io/badge/X11-F28D1A?style=for-the-badge&logo=x.org&logoColor=white)
![Linux](https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&logo=linux&logoColor=black)

[â† Retour au README](README.md)

</div>

---

## ğŸ“‘ Table des matiÃ¨res

- [Pourquoi read() ne suffit plus ?](#1%EF%B8%8Fâƒ£-avant-x11--pourquoi-read-ne-suffit-plus-)
- [X11 : qui fait quoi ?](#2%EF%B8%8Fâƒ£-x11--qui-fait-quoi-exactement-)
- [Court-circuiter le Window Manager](#3%EF%B8%8Fâƒ£-objectif--court-circuiter-le-window-manager)
- [Le bug de read()](#4%EF%B8%8Fâƒ£-pourquoi-read-casse-aprÃ¨s-le-grab-)
- [Le vrai flux clavier X11](#5%EF%B8%8Fâƒ£-le-vrai-flux-clavier-x11)
- [KeyCode â†’ KeySym](#6%EF%B8%8Fâƒ£-traduire-une-touche--keycode--keysym)
- [La sÃ©quence secrÃ¨te](#7%EF%B8%8Fâƒ£-implÃ©mentation-pÃ©dagogique--la-sÃ©quence-secrÃ¨te)
- [Wayland vs X11](#-wayland-vs-x11)

---

## 1ï¸âƒ£ Avant X11 : pourquoi `read()` ne suffit plus ?

### Ce que font la plupart des programmes terminal

En C "classique", on lit le clavier comme Ã§a :

```c
char c;
read(STDIN_FILENO, &c, 1);
```

```
ğŸ‘‰ Le terminal reÃ§oit les touches
ğŸ‘‰ Il les traduit en caractÃ¨res
ğŸ‘‰ Puis les envoie au programme via stdin
```

### âŒ ProblÃ¨me fondamental

> **`Alt+Tab`, `Alt+F4`, `Super`, etc. n'arrivent jamais au terminal**

â¡ï¸ Le **Window Manager** les intercepte **avant**.

Donc :
- âŒ Ton programme ne voit rien
- âŒ MÃªme si tu bloques `SIGINT`, `SIGTERM`, etc.

---

## 2ï¸âƒ£ X11 : qui fait quoi exactement ?

### Le modÃ¨le X11 (simplifiÃ©)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        MATÃ‰RIEL             â”‚
â”‚   Clavier  Â·  Souris        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚  (signaux bruts)
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        SERVEUR X11          â”‚
â”‚     (X Server / Xorg)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                   â”‚
    â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WINDOW        â”‚  â”‚ APPLICATION   â”‚
â”‚ MANAGER       â”‚  â”‚ (xterm, ton   â”‚
â”‚ (GNOME/KDE)   â”‚  â”‚  programme)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> [!NOTE]
> ğŸ”‘ **Point clÃ©** : Le terminal n'est pas le propriÃ©taire du clavier.  
> ğŸ‘‰ **X11 l'est.**

---

## 3ï¸âƒ£ Objectif : court-circuiter le Window Manager

### Le problÃ¨me rÃ©el

> *"Je veux recevoir toutes les touches, mÃªme celles que le systÃ¨me rÃ©serve."*

**âŒ Impossible avec :**
- `stdin`
- `termios`
- `signal()`

### âœ… La solution : Keyboard Grab

```c
XGrabKeyboard(
    dpy,            // Connexion au serveur X
    root,           // FenÃªtre racine
    False,
    GrabModeAsync,
    GrabModeAsync,
    CurrentTime
);
```

> *"Serveur X11, Ã  partir de maintenant : **toutes les touches sont pour moi**."*

**RÃ©sultat :**
- âœ… Le Window Manager devient **aveugle**
- âœ… `Alt+Tab`, `Alt+F4`, `Super` â†’ **neutralisÃ©s**
- âœ… Ton programme reÃ§oit le **flux brut**

---

## 4ï¸âƒ£ Pourquoi `read()` casse aprÃ¨s le grab ?

### âš ï¸ Effet secondaire important

Une fois le clavier capturÃ© :
- âŒ Le terminal ne reÃ§oit plus rien
- âŒ `stdin` est vide
- âŒ `read()` bloque Ã  l'infini

> [!WARNING]
> ğŸ’¥ D'oÃ¹ le bug :  
> *"Le clavier est capturÃ©â€¦ mais plus rien ne fonctionne"*

---

## 5ï¸âƒ£ Le vrai flux clavier X11

Avec X11, le clavier ne produit pas des **caractÃ¨res**, mais des **Ã©vÃ©nements**.

### Boucle d'Ã©vÃ©nements X11

```c
while (XPending(dpy)) {
    XNextEvent(dpy, &ev);
}
```

Chaque touche gÃ©nÃ¨re :
- ğŸ“¥ un `KeyPress`
- ğŸ“¤ un `KeyRelease`

---

## 6ï¸âƒ£ Traduire une touche : KeyCode â†’ KeySym

X11 ne donne pas directement `'a'`, `'m'`, `'p'`.

Il donne :
- Un **KeyCode** (position physique)
- Qu'on traduit en **KeySym** (symbole logique)

```c
KeySym keysym = XLookupKeysym(&ev.xkey, 0);
```

### Exemples de KeySym

| KeySym | Touche |
|:------:|:------:|
| `XK_m` | M |
| `XK_p` | P |
| `XK_Escape` | Ã‰chap |
| `XK_F4` | F4 |

â¡ï¸ LÃ  seulement tu peux comparer avec `'m'`, `'p'`.

---

## 7ï¸âƒ£ ImplÃ©mentation pÃ©dagogique : la sÃ©quence secrÃ¨te

```c
if (keysym == XK_m)
    last_key = 'm';
else if (last_key == 'm' && keysym == XK_p)
    locked = 0;
else
    last_key = 0;
```

### Pourquoi cette logique ?

| PropriÃ©tÃ© | Description |
|-----------|-------------|
| ğŸ”„ **SÃ©quentielle** | Pas instantanÃ©e |
| ğŸ›¡ï¸ **RÃ©sistante** | Au spam clavier |
| ğŸ”§ **Extensible** | Mot de passe, Konami codeâ€¦ |

---

## 8ï¸âƒ£ X11 â‰  plein Ã©cran

X11 **ne force pas** le plein Ã©cran :
- Le Window Manager dÃ©cide
- X11 ne fait que router des Ã©vÃ©nements

### Ruse utilisÃ©e

```bash
xterm -xrm 'xterm.overrideRedirect: true'
```

| Effet | RÃ©sultat |
|-------|----------|
| â¡ï¸ Le WM n'est pas autorisÃ© | Ã€ gÃ©rer la fenÃªtre |
| â¡ï¸ Pas de bordure | âœ… |
| â¡ï¸ Pas de barre | âœ… |
| â¡ï¸ Pas de focus loss | âœ… |

---

## 9ï¸âƒ£ Le nettoyage : rÃ¨gle d'or X11

### âš ï¸ Pourquoi c'est critique

Si ton programme crash **sans** :

```c
XUngrabKeyboard(dpy, CurrentTime);
```

> [!CAUTION]
> ğŸ‘‰ Le clavier peut rester **bloquÃ©**  
> ğŸ‘‰ Pour **toute** la session X

### âœ… Toujours restaurer

```c
XUngrabKeyboard(dpy, CurrentTime);
XCloseDisplay(dpy);
printf("\033[?1049l\033[?25h");
```

---

## ğŸ”¥ RÃ©sumÃ© mental

<div align="center">

```
ğŸ§  X11 n'est pas une bibliothÃ¨que graphique.
   C'est le chef d'orchestre du matÃ©riel d'entrÃ©e.
```

| Couche | Fonction |
|:------:|----------|
| `stdin` | texte |
| `X11` | matÃ©riel brut |
| `Window Manager` | filtre systÃ¨me |
| `XGrabKeyboard` | court-circuit total |

</div>

---

## ğŸ“ Ce que ce projet m'a appris

- âœ… Comment Linux gÃ¨re le clavier **rÃ©ellement**
- âœ… Pourquoi certains raccourcis sont "impossibles" Ã  intercepter
- âœ… Comment fonctionne une **event loop graphique**
- âœ… La diffÃ©rence entre **illusion visuelle** et **contrÃ´le systÃ¨me**

---

## ğŸ§ª Exercices conseillÃ©s

1. ğŸ“ Modifier le code pour afficher le `KeySym` de chaque touche
2. ğŸ® ImplÃ©menter une sÃ©quence type : `â†‘ â†‘ â†“ â†“ â† â†’ â† â†’ B A`
3. â±ï¸ Ajouter une touche de sortie d'urgence (`Escape` + 5s)

---

<div align="center">

# ğŸ”„ Wayland vs X11

### *Comprendre la diffÃ©rence fondamentale*

</div>

---

## La philosophie

<div align="center">

| X11 | Wayland |
|:---:|:-------:|
| ğŸ”“ **Confiance + LibertÃ©** | ğŸ”’ **SÃ©curitÃ© + ContrÃ´le** |

</div>

---

## X11 : le modÃ¨le "serveur central permissif"

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Clavier     â”‚
        â”‚  Souris      â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  SERVEUR X11     â”‚
        â”‚  (Xorg)          â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                   â”‚
      â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Window      â”‚     â”‚ Application â”‚
â”‚ Manager     â”‚     â”‚ (xterm, C)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚
       â””â”€â”€â”€â”€â”€ Interception â”‚
             (Alt+Tab...)  â”‚
```

### CaractÃ©ristiques clÃ©s

- ğŸ›ï¸ Un **serveur central** qui gÃ¨re Ã©cran + clavier + souris
- ğŸ”“ Toute application X11 peut :
  - Ã‰couter le clavier
  - Espionner d'autres fenÃªtres
  - Grabber les entrÃ©es

> â¡ï¸ Puissance Ã©norme, mais **faille de sÃ©curitÃ© structurelle**.

---

## Wayland : le modÃ¨le "zÃ©ro confiance"

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Clavier     â”‚
        â”‚  Souris      â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  COMPOSITOR WAYLAND     â”‚
        â”‚ (Weston / GNOME / KDE)  â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              â”‚
        â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application â”‚   â”‚ Application â”‚
â”‚      A      â”‚   â”‚      B      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Comparaison dÃ©taillÃ©e

| Concept | X11 | Wayland |
|:-------:|:---:|:-------:|
| Serveur central | âœ… Oui | âŒ Non |
| AccÃ¨s clavier global | âœ… Oui | âŒ Non |
| Keylogging possible | âš ï¸ Oui | ğŸ›¡ï¸ BloquÃ© |
| Grab clavier | âœ… Oui | âŒ Interdit |
| SÃ©curitÃ© | âš ï¸ Faible | ğŸ›¡ï¸ Forte |
| LibertÃ© dev | ğŸ”“ Totale | ğŸ”’ EncadrÃ©e |

---

## âŒ Pourquoi ce projet NE PEUT PAS marcher sous Wayland

### Ce que Wayland interdit explicitement

- âŒ Intercepter les touches globales
- âŒ Bloquer `Alt+Tab`
- âŒ Lire le clavier hors focus
- âŒ Espionner d'autres apps

```c
XGrabKeyboard()   // âŒ interdit
XLookupKeysym()   // âŒ hors focus
```

> [!IMPORTANT]
> MÃªme avec `sudo`, `root`, ou des permissions spÃ©ciales.  
> â¡ï¸ C'est un **choix de design**, pas une limitation technique.

---

## âš ï¸ XWayland : le piÃ¨ge courant

> *"Mais Ã§a marche chez moi sous Wayland !"*

En rÃ©alitÃ© :

```
Wayland
   â†“
XWayland (compatibilitÃ© X11)
   â†“
Application X11
```

**Mais :**
- Le compositor Wayland garde le contrÃ´le
- Certains grabs sont ignorÃ©s
- Comportement non garanti

> â¡ï¸ XWayland = **bac Ã  sable**, pas X11 rÃ©el.

---

## ğŸ” OÃ¹ se situent les vrais lockscreens modernes

| Environnement | Lockscreen |
|:-------------:|:----------:|
| GNOME | `gnome-shell` |
| KDE | `kscreenlocker` |
| Wayland | IntÃ©grÃ© au compositor |
| X11 | Possible cÃ´tÃ© userland âš ï¸ |

---

## ğŸ§  SchÃ©ma mental final

<div align="center">

```
X11      â†’ LibertÃ© totale   â†’ Risques
Wayland  â†’ SÃ©curitÃ© totale  â†’ Restrictions
```

</div>

---

## ğŸ Conclusion

<div align="center">

Voici pourquoi **X11 permet ce genre de hack**  
et pourquoi **Wayland l'a rendu impossible**.

---

**X11** = *"Les applications sont dignes de confiance"*

**Wayland** = *"Les applications sont hostiles par dÃ©faut"*

<br/>

[â† Retour au README](README.md)

</div>
