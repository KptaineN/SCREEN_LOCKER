ğŸ§  Comprendre X11 â€” Guide pÃ©dagogique appliquÃ©
(Ã€ partir du projet Black Hole / Starfield Locker)

1ï¸âƒ£ Avant X11 : pourquoi read() ne suffit plus ?
Ce que font la plupart des programmes terminal
En C â€œclassiqueâ€, on lit le clavier comme Ã§a :
char c;
read(STDIN_FILENO, &c, 1);
ğŸ‘‰ Le terminal reÃ§oit les touches,
ğŸ‘‰ il les traduit en caractÃ¨res,
ğŸ‘‰ puis les envoie au programme via stdin.
ProblÃ¨me fondamental
    â€¢ Alt+Tab, Alt+F4, Super, etc.
    â€¢ nâ€™arrivent jamais au terminal
â¡ï¸ Le Window Manager les intercepte avant.
Donc :
    â€¢ ton programme ne voit rien
    â€¢ mÃªme si tu bloques SIGINT, SIGTERM, etc.

2ï¸âƒ£ X11 : qui fait quoi exactement ?
Le modÃ¨le X11 (simplifiÃ©)
[ Clavier / Souris ]
        â†“
[ Serveur X11 ]
        â†“
[ Window Manager ]
        â†“
[ FenÃªtre / Application ]
ğŸ”‘ Point clÃ©
Le terminal nâ€™est pas le propriÃ©taire du clavier.
ğŸ‘‰ X11 lâ€™est.

3ï¸âƒ£ Objectif : court-circuiter le Window Manager
Le problÃ¨me rÃ©el
â€œJe veux recevoir toutes les touches, mÃªme celles que le systÃ¨me rÃ©serve.â€
Impossible avec :
    â€¢ stdin
    â€¢ termios
    â€¢ signal()
La solution : Keyboard Grab
XGrabKeyboard(
    dpy,            // Connexion au serveur X
    root,           // FenÃªtre racine
    False,
    GrabModeAsync,
    GrabModeAsync,
    CurrentTime
);
Ce que Ã§a signifie
â€œServeur X11, Ã  partir de maintenant :
toutes les touches sont pour moi.â€
RÃ©sultat :
    â€¢ le Window Manager devient aveugle
    â€¢ Alt+Tab, Alt+F4, Super â†’ neutralisÃ©s
    â€¢ ton programme reÃ§oit le flux brut

4ï¸âƒ£ Pourquoi read() casse aprÃ¨s le grab ?
Effet secondaire important
Une fois le clavier capturÃ© :
    â€¢ le terminal ne reÃ§oit plus rien
    â€¢ stdin est vide
    â€¢ read() bloque Ã  lâ€™infini
ğŸ’¥ Dâ€™oÃ¹ le bug :
â€œLe clavier est capturÃ©â€¦ mais plus rien ne fonctionneâ€

5ï¸âƒ£ Le vrai flux clavier X11
Avec X11, le clavier ne produit pas des caractÃ¨res, mais des Ã©vÃ©nements.
Boucle dâ€™Ã©vÃ©nements X11
while (XPending(dpy)) {
    XNextEvent(dpy, &ev);
}
Chaque touche gÃ©nÃ¨re :
    â€¢ un KeyPress
    â€¢ un KeyRelease

6ï¸âƒ£ Traduire une touche : KeyCode â†’ KeySym
X11 ne donne pas directement 'a', 'm', 'p'.
Il donne :
    â€¢ un KeyCode (position physique)
    â€¢ quâ€™on traduit en KeySym (symbole logique)
KeySym keysym = XLookupKeysym(&ev.xkey, 0);
Exemples :
    â€¢ XK_m
    â€¢ XK_p
    â€¢ XK_Escape
    â€¢ XK_F4
â¡ï¸ LÃ  seulement tu peux comparer avec 'm', 'p'.

7ï¸âƒ£ ImplÃ©mentation pÃ©dagogique : la sÃ©quence secrÃ¨te
if (keysym == XK_m)
    last_key = 'm';
else if (last_key == 'm' && keysym == XK_p)
    locked = 0;
else
    last_key = 0;
Pourquoi cette logique ?
    â€¢ sÃ©quentielle (pas instantanÃ©e)
    â€¢ rÃ©sistante au spam clavier
    â€¢ facile Ã  Ã©tendre (mot de passe, Konami codeâ€¦)

8ï¸âƒ£ X11 â‰  plein Ã©cran (et pourquoi xterm est utilisÃ©)
X11 ne force pas le plein Ã©cran :
    â€¢ le Window Manager dÃ©cide
    â€¢ X11 ne fait que router des Ã©vÃ©nements
Ruse utilisÃ©e
xterm -xrm 'xterm.overrideRedirect: true'
â¡ï¸ Le WM nâ€™est pas autorisÃ© Ã  gÃ©rer la fenÃªtre
â¡ï¸ Pas de bordure
â¡ï¸ Pas de barre
â¡ï¸ Pas de focus loss

9ï¸âƒ£ Le nettoyage : rÃ¨gle dâ€™or X11
Pourquoi câ€™est critique
Si ton programme crash sans :
XUngrabKeyboard(dpy, CurrentTime);
ğŸ‘‰ le clavier peut rester bloquÃ©
ğŸ‘‰ pour toute la session X
Toujours restaurer :
XUngrabKeyboard(dpy, CurrentTime);
XCloseDisplay(dpy);
printf("\033[?1049l\033[?25h");

ğŸ”¥ RÃ©sumÃ© mental (Ã  retenir par cÅ“ur)
ğŸ§  X11 nâ€™est pas une bibliothÃ¨que graphique.
Câ€™est le chef dâ€™orchestre du matÃ©riel dâ€™entrÃ©e.
    â€¢ stdin â†’ texte
    â€¢ X11 â†’ matÃ©riel brut
    â€¢ Window Manager â†’ filtre systÃ¨me
    â€¢ XGrabKeyboard â†’ court-circuit total

ğŸ“ Ce que ce projet mâ€™a rÃ©ellement appris
    â€¢ Comment Linux gÃ¨re le clavier rÃ©ellement
    â€¢ Pourquoi certains raccourcis sont â€œimpossiblesâ€ Ã  intercepter
    â€¢ Comment fonctionne une event loop graphique
    â€¢ La diffÃ©rence entre :
        â—¦ illusion visuelle
        â—¦ contrÃ´le systÃ¨me

ğŸ§ª Exercice conseillÃ© (pour maÃ®triser)
1ï¸âƒ£ Modifier le code pour afficher le KeySym de chaque touche
2ï¸âƒ£ ImplÃ©menter une sÃ©quence type :
â†‘ â†‘ â†“ â†“ â† â†’ â† â†’ B A
3ï¸âƒ£ Ajouter une touche de sortie dâ€™urgence (Escape + 5s)



Voici un schÃ©ma ASCII clair, pÃ©dagogique et mÃ©morisable du fonctionnement X11, exactement dans lâ€™esprit â€œje dois pouvoir lâ€™expliquer de tÃªte Ã  un humainâ€.

                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚        MATÃ‰RIEL             â”‚
                â”‚  Clavier  Â·  Souris         â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚  (signaux bruts)
                              â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚        SERVEUR X11           â”‚
                â”‚  (X Server / Xorg)           â”‚
                â”‚                               â”‚
                â”‚  - ReÃ§oit les events matÃ©rielsâ”‚
                â”‚  - GÃ¨re Ã©crans & entrÃ©es     â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                                   â”‚
            â–¼                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   WINDOW MANAGER    â”‚            â”‚     APPLICATION     â”‚
â”‚  (GNOME / KDE / i3)â”‚            â”‚  (xterm, ton prog)  â”‚
â”‚                     â”‚            â”‚                     â”‚
â”‚  - Alt+Tab          â”‚            â”‚  - stdin / ANSI     â”‚
â”‚  - Alt+F4           â”‚            â”‚  - X11 events       â”‚
â”‚  - Focus            â”‚            â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                                   â”‚
          â””â”€â”€â”€â”€â”€(bloque / intercepte)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”‘ Cas NORMAL (sans XGrabKeyboard)
Clavier
   â†“
X Server
   â†“
Window Manager  â”€â”€â–º (Alt+Tab / Alt+F4 interceptÃ©s)
   â†“
Terminal
   â†“
stdin (read())
â¡ï¸ Ton programme ne voit jamais les touches systÃ¨me.

ğŸ” Cas AVEC XGrabKeyboard (ton projet)
Clavier
   â†“
X Server
   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TON PROGRAMME (XGrabKeyboard) â”‚
â”‚                                 â”‚
â”‚  - reÃ§oit TOUTES les touches    â”‚
â”‚  - WM devient sourd             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“
Event Loop X11 (XNextEvent)
â¡ï¸ Le Window Manager est court-circuitÃ©.

ğŸ¯ OÃ¹ se situe ton code exactement ?
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TON PROGRAMME               â”‚
â”‚                                          â”‚
â”‚  XOpenDisplay()                           â”‚
â”‚        â†“                                 â”‚
â”‚  XGrabKeyboard()  â—„â”€â”€â”€ ğŸ” VERROU          â”‚
â”‚        â†“                                 â”‚
â”‚  while (locked)                           â”‚
â”‚  {                                       â”‚
â”‚     XPending()                            â”‚
â”‚     XNextEvent()                          â”‚
â”‚     KeyPress â†’ XLookupKeysym()            â”‚
â”‚     if (m puis p) unlock                 â”‚
â”‚  }                                       â”‚
â”‚                                          â”‚
â”‚  XUngrabKeyboard()  â—„â”€â”€ ğŸ§¹ RESTAURATION   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ§  SchÃ©ma mental ultra-simple (Ã  rÃ©citer)
Clavier â†’ X11 â†’ (Window Manager ?) â†’ Application
           â”‚
           â””â”€â–º XGrabKeyboard = prioritÃ© absolue

âš ï¸ RÃ¨gle dâ€™or X11 (Ã  ne jamais oublier)
Si tu grab â†’ tu ungrab.
Sinon â†’ clavier bloquÃ©.

ğŸ§ª Bonus : diffÃ©rence stdin vs X11
stdin      = texte
X11        = matÃ©riel
read()     = caractÃ¨res
XNextEvent = Ã©vÃ©nements physiques

ğŸ Conclusion
X11 nâ€™est pas un affichage.
Câ€™est un routeur dâ€™entrÃ©es/sorties.



ğŸ§  Wayland vs X11 â€” Comprendre la diffÃ©rence fondamentale
X11 = confiance + libertÃ©
Wayland = sÃ©curitÃ© + contrÃ´le

1ï¸âƒ£ X11 : le modÃ¨le â€œserveur central permissifâ€
SchÃ©ma ASCII â€” X11
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Clavier     â”‚
        â”‚  Souris      â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  SERVEUR X11     â”‚
        â”‚  (Xorg)          â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                   â”‚
      â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Window      â”‚     â”‚ Application â”‚
â”‚ Manager     â”‚     â”‚ (xterm, C)  â”‚
â”‚             â”‚     â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚
       â””â”€â”€â”€â”€â”€ Interception â”‚
             (Alt+Tab...)  â”‚
CaractÃ©ristiques clÃ©s
    â€¢ Un serveur central :
        â—¦ gÃ¨re Ã©cran + clavier + souris
    â€¢ Toute application X11 peut :
        â—¦ Ã©couter le clavier
        â—¦ espionner dâ€™autres fenÃªtres
        â—¦ grabber les entrÃ©es
â¡ï¸ Puissance Ã©norme, mais faille de sÃ©curitÃ© structurelle.

2ï¸âƒ£ Pourquoi XGrabKeyboard est possible sous X11
Sous X11 :
    â€¢ Le serveur fait confiance aux applications
    â€¢ Il accepte :
    â€¢ XGrabKeyboard(...)
    â€¢ Le WM ne peut rien faire
ğŸ‘‰ Câ€™est ce qui rend ton projet possible.


3ï¸âƒ£ Wayland : le modÃ¨le â€œzÃ©ro confianceâ€
Wayland a Ã©tÃ© crÃ©Ã© pour corriger les failles X11.
SchÃ©ma ASCII â€” Wayland
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Clavier     â”‚
        â”‚  Souris      â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  COMPOSITOR WAYLAND     â”‚
        â”‚ (Weston / GNOME / KDE)  â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              â”‚
        â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application â”‚   â”‚ Application â”‚
â”‚    A        â”‚   â”‚    B        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4ï¸âƒ£ DiffÃ©rence philosophique majeure
Concept
X11
Wayland
Serveur central
Oui
Non
AccÃ¨s clavier global
Oui
âŒ Non
Keylogging possible
Oui
âŒ BloquÃ©
Grab clavier
Oui
âŒ Interdit
SÃ©curitÃ©
Faible
Forte
LibertÃ© dev
Totale
EncadrÃ©e

5ï¸âƒ£ Pourquoi ce projet NE PEUT PAS marcher sous Wayland
Ce que Wayland interdit explicitement
    â€¢ âŒ intercepter les touches globales
    â€¢ âŒ bloquer Alt+Tab
    â€¢ âŒ lire le clavier hors focus
    â€¢ âŒ espionner dâ€™autres apps
Donc :
XGrabKeyboard()  âŒ interdit
XLookupKeysym() âŒ hors focus
MÃªme avec :
    â€¢ sudo
    â€¢ root
    â€¢ permissions
â¡ï¸ Câ€™est un choix de design, pas une limitation technique.

6ï¸âƒ£ XWayland : le piÃ¨ge courant
â€œMais Ã§a marche chez moi sous Wayland !â€
En rÃ©alitÃ© :
Wayland
   â†“
XWayland (compatibilitÃ© X11)
   â†“
Application X11
Mais :
    â€¢ le compositor Wayland garde le contrÃ´le
    â€¢ certains grabs sont ignorÃ©s
    â€¢ comportement non garanti
â¡ï¸ XWayland = bac Ã  sable, pas X11 rÃ©el.

7ï¸âƒ£ RÃ©sumÃ©
X11 :
"Les applications sont dignes de confiance"

Wayland :
"Les applications sont hostiles par dÃ©faut"

8ï¸âƒ£ Cela montre
    â€¢ Pourquoi X11 est puissant mais dangereux
    â€¢ Pourquoi Wayland a Ã©tÃ© crÃ©Ã©
    â€¢ Pourquoi les lockscreens modernes sont :
        â—¦ intÃ©grÃ©s au compositor
        â—¦ jamais des apps utilisateur

9ï¸âƒ£ OÃ¹ se situent les vrais lockscreens modernes
Environnement
Lockscreen
GNOME
gnome-shell
KDE
kscreenlocker
Wayland
intÃ©grÃ© au compositor
X11
possible cÃ´tÃ© userland (dangereux)

ğŸ§  SchÃ©ma mental final
X11      â†’ libertÃ© totale â†’ risques
Wayland  â†’ sÃ©curitÃ© totale â†’ restrictions

ğŸ Conclusion
voici  pourquoi X11 permet ce genre de hack
et pourquoi Wayland lâ€™a rendu impossible.
